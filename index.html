# === COPY/PASTE “TODO EN UNO” ===
# Incluye:
# 1) functions/package.json
# 2) functions/index.js  (ask + bootstrapAdmin + setRole)
# 3) firestore.rules
# 4) Frontend: reemplazo de fetchGemini() (usa tu Function)
# 5) Comandos de despliegue

───────────────────────────────────────────────────────────────────────────────
FILE: functions/package.json
───────────────────────────────────────────────────────────────────────────────
{
  "name": "spei-ops-functions",
  "private": true,
  "type": "module",
  "engines": { "node": "20" },
  "dependencies": {
    "firebase-admin": "^12.5.0",
    "firebase-functions": "^6.0.1"
  }
}

───────────────────────────────────────────────────────────────────────────────
FILE: functions/index.js
───────────────────────────────────────────────────────────────────────────────
import { onRequest, onCall } from "firebase-functions/v2/https";
import { logger } from "firebase-functions";
import { defineSecret } from "firebase-functions/params";
import admin from "firebase-admin";

admin.initializeApp();

/**
 * Secrets (Firebase Functions > Secrets)
 * - GEMINI_API_KEY: tu API key de Gemini (NO en GitHub Pages)
 * - BOOTSTRAP_TOKEN: token largo para otorgar el primer admin (1 vez)
 */
const GEMINI_API_KEY = defineSecret("GEMINI_API_KEY");
const BOOTSTRAP_TOKEN = defineSecret("BOOTSTRAP_TOKEN");

// ✅ Debe coincidir con tu appId del front (lo tienes como "chatbot-8d0a3")
const APP_ID = "chatbot-8d0a3";

// ✅ Ajusta a tu dominio exacto de GitHub Pages
const ALLOWED_ORIGINS = new Set([
  "https://danzaldog03-create.github.io"
]);

function setCors(req, res) {
  const origin = req.headers.origin || "";
  if (ALLOWED_ORIGINS.has(origin)) {
    res.set("Access-Control-Allow-Origin", origin);
  }
  res.set("Vary", "Origin");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
}

function normalize(s) {
  return (s || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^\p{L}\p{N}\s]/gu, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function pickRelevantEntries(question, kbEntries, k = 8) {
  const q = normalize(question);
  const terms = q.split(" ").filter(t => t.length >= 3);
  if (terms.length === 0) return kbEntries.slice(0, k);

  const scored = kbEntries.map(e => {
    const hay = normalize(`${e.title || ""} ${e.content || ""} ${e.category || ""}`);
    const title = normalize(e.title || "");
    let score = 0;

    for (const t of terms) {
      if (hay.includes(t)) score += 1;
      if (title.includes(t)) score += 2; // boost título
    }
    return { e, score };
  });

  scored.sort((a, b) => b.score - a.score);
  const top = scored.filter(x => x.score > 0).slice(0, k).map(x => x.e);
  return top.length ? top : kbEntries.slice(0, k);
}

/**
 * Rate limit básico por IP (evita abuso sencillo).
 */
const ipBucket = new Map();
function rateLimit(req, res) {
  const ip = (req.headers["x-forwarded-for"] || req.socket.remoteAddress || "")
    .toString()
    .split(",")[0]
    .trim();

  const now = Date.now();
  const windowMs = 60_000; // 1 min
  const maxReq = 30;       // 30/min

  const arr = ipBucket.get(ip) || [];
  const filtered = arr.filter(t => now - t < windowMs);
  filtered.push(now);
  ipBucket.set(ip, filtered);

  if (filtered.length > maxReq) {
    res.status(429).json({ answer: "Demasiadas consultas. Intenta de nuevo en 1 minuto." });
    return true;
  }
  return false;
}

/**
 * ✅ Endpoint principal para tu front.
 * Front -> POST /ask { question, sessionId }
 * Backend:
 *  - Lee KB de Firestore
 *  - Hace top-k (keyword scoring)
 *  - Llama Gemini con la key (secret)
 *  - Regresa answer
 */
export const ask = onRequest(
  {
    region: "us-central1",
    timeoutSeconds: 60,
    memory: "512MiB",
    secrets: [GEMINI_API_KEY]
  },
  async (req, res) => {
    setCors(req, res);

    if (req.method === "OPTIONS") {
      res.status(204).send("");
      return;
    }
    if (req.method !== "POST") {
      res.status(405).json({ answer: "Método no permitido." });
      return;
    }
    if (rateLimit(req, res)) return;

    try {
      const { question, sessionId } = req.body || {};
      const q = (question || "").toString().trim();
      if (!q) {
        res.status(400).json({ answer: "Pregunta vacía." });
        return;
      }

      // Lee KB (MISMA estructura que ya tienes)
      const kbSnap = await admin
        .firestore()
        .collection("artifacts")
        .doc(APP_ID)
        .collection("public")
        .doc("data")
        .collection("knowledge")
        .get();

      const kbAll = kbSnap.docs.map(d => ({ id: d.id, ...d.data() }));
      const kbTop = pickRelevantEntries(q, kbAll, 8);

      const context = kbTop
        .map(e =>
          `### ${e.title || "SIN TÍTULO"}\n` +
          `CATEGORÍA: ${e.category || "N/A"}\n` +
          `CONTENIDO:\n${(e.content || "").slice(0, 7000)}`
        )
        .join("\n\n---\n\n");

      const systemPrompt = `
ACTÚA COMO ASISTENTE TÉCNICO EXPERTO DE OPERACIÓN SPEI/CoDi/SPID.
TU ÚNICA FUENTE ES EL CONTEXTO. NO INVENTES DATOS.

REGLAS:
1) Si el dato está en el contexto, úsalo y sé específico.
2) Si piden explicación/ejemplo, razona SOLO con el contexto (sin datos externos).
3) Si NO está, responde EXACTO:
"Esa información no se encuentra registrada en el manual operativo."
4) Respuesta directa, sin saludos redundantes. Usa "###" para secciones.

CONTEXTO:
${context}
`.trim();

      const url =
        `https://generativelanguage.googleapis.com/v1beta/models/` +
        `gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY.value()}`;

      const payload = {
        systemInstruction: { parts: [{ text: systemPrompt }] },
        contents: [{ role: "user", parts: [{ text: q }] }],
        generationConfig: { temperature: 0.2, topP: 0.9, maxOutputTokens: 900 }
      };

      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const data = await r.json();
      const answer =
        data?.candidates?.[0]?.content?.parts?.[0]?.text?.toString()?.trim() ||
        "Sin respuesta técnica.";

      // Log básico (opcional pero útil)
      await admin
        .firestore()
        .collection("artifacts")
        .doc(APP_ID)
        .collection("public")
        .doc("data")
        .collection("logs")
        .add({
          sessionId: sessionId || null,
          question: q,
          answer,
          topKbIds: kbTop.map(x => x.id),
          ts: admin.firestore.FieldValue.serverTimestamp()
        });

      res.json({ answer });
    } catch (e) {
      logger.error(e);
      res.status(500).json({ answer: "Fallo de conexión operativa." });
    }
  }
);

/**
 * ✅ Bootstrapping de Admin (Custom Claims) — 1 vez.
 * Úsalo para darte a ti mismo el primer rol admin.
 *
 * Llamada (desde tu PC):
 * curl -X POST <URL_BOOTSTRAP> -H "Content-Type: application/json" \
 *  -d '{"uid":"<TU_UID>","token":"<BOOTSTRAP_TOKEN>"}'
 *
 * NOTA: Una vez que ya tengas admin, cambia el BOOTSTRAP_TOKEN por uno nuevo
 * o elimínalo para “cerrar” el bootstrap.
 */
export const bootstrapAdmin = onRequest(
  {
    region: "us-central1",
    timeoutSeconds: 30,
    memory: "256MiB",
    secrets: [BOOTSTRAP_TOKEN]
  },
  async (req, res) => {
    setCors(req, res);

    if (req.method === "OPTIONS") {
      res.status(204).send("");
      return;
    }
    if (req.method !== "POST") {
      res.status(405).json({ ok: false, error: "Método no permitido." });
      return;
    }

    try {
      const { uid, token } = req.body || {};
      if (!uid || !token) {
        res.status(400).json({ ok: false, error: "Faltan uid/token." });
        return;
      }
      if (token !== BOOTSTRAP_TOKEN.value()) {
        res.status(403).json({ ok: false, error: "Token inválido." });
        return;
      }

      // Set custom claim
      await admin.auth().setCustomUserClaims(uid, { role: "admin" });

      // (Opcional) Registra en team, manteniendo tu estructura
      await admin.firestore()
        .collection("artifacts").doc(APP_ID)
        .collection("public").doc("data")
        .collection("team").doc(uid)
        .set(
          { name: "Admin", empNumber: "ADMIN", role: "admin", queries: 0, uid },
          { merge: true }
        );

      res.json({ ok: true, message: "Admin otorgado. Cierra el bootstrap cambiando/eliminando el token." });
    } catch (e) {
      logger.error(e);
      res.status(500).json({ ok: false, error: "Error interno." });
    }
  }
);

/**
 * ✅ Gestión de roles (solo admins)
 * Frontend (o herramienta) puede llamar a esta callable para dar/quitar admin.
 * Requiere que el caller YA tenga claim role=admin.
 */
export const setRole = onCall(
  { region: "us-central1", timeoutSeconds: 30, memory: "256MiB" },
  async (req) => {
    const caller = req.auth;
    if (!caller) throw new Error("UNAUTHENTICATED");
    if (caller.token?.role !== "admin") throw new Error("PERMISSION_DENIED");

    const { uid, role } = req.data || {};
    if (!uid || !role) throw new Error("INVALID_ARGUMENT");
    if (!["admin", "user"].includes(role)) throw new Error("INVALID_ARGUMENT");

    await admin.auth().setCustomUserClaims(uid, { role });

    // Mantén sincronizado tu registro team si quieres
    await admin.firestore()
      .collection("artifacts").doc(APP_ID)
      .collection("public").doc("data")
      .collection("team").doc(uid)
      .set({ uid, role }, { merge: true });

    return { ok: true };
  }
);

───────────────────────────────────────────────────────────────────────────────
FILE: firestore.rules
───────────────────────────────────────────────────────────────────────────────
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isAdmin() { return isSignedIn() && request.auth.token.role == "admin"; }

    // ✅ Mantienes tu estructura actual:
    // artifacts/{appId}/public/data/knowledge/{docId}
    match /artifacts/{appId}/public/data/knowledge/{docId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /artifacts/{appId}/public/data/team/{docId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }

    match /artifacts/{appId}/public/data/logs/{docId} {
      allow read: if isAdmin();
      allow write: if false; // lo escribe backend (ask). no desde cliente
    }
  }
}

───────────────────────────────────────────────────────────────────────────────
FRONTEND: reemplazo de fetchGemini(q) (pega tal cual)
───────────────────────────────────────────────────────────────────────────────
const BACKEND_ASK_URL = "https://us-central1-TU_PROYECTO.cloudfunctions.net/ask"; // <-- cambia esto

async function fetchGemini(q) {
  try {
    const sessionId = currentUser?.empNumber || "anon";
    const res = await fetch(BACKEND_ASK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ question: q, sessionId })
    });
    const data = await res.json();
    return data?.answer || "Sin respuesta técnica.";
  } catch (e) {
    return "Fallo de conexión operativa.";
  }
}

───────────────────────────────────────────────────────────────────────────────
COMANDOS (resumen)
───────────────────────────────────────────────────────────────────────────────
# 1) Instalar CLI y crear functions
npm i -g firebase-tools
firebase login
firebase init functions
# (cuando te pregunte, usa Node 20, JavaScript; y reemplaza con estos archivos)

# 2) Instalar deps
cd functions
npm i
cd ..

# 3) Crear secrets
firebase functions:secrets:set GEMINI_API_KEY
firebase functions:secrets:set BOOTSTRAP_TOKEN
# (usa un token largo tipo: 32-64 chars random)

# 4) Deploy
firebase deploy --only functions
firebase deploy --only firestore:rules

# 5) Bootstrap admin (1 vez)
# Necesitas TU UID (si estás usando Auth anónimo actual, lo puedes ver en consola del navegador:
# firebase.auth().currentUser.uid si usas compat; en tu caso modular:
# window.fb.auth.currentUser.uid  (después de signInAnonymously)
#
# Luego:
curl -X POST "https://us-central1-TU_PROYECTO.cloudfunctions.net/bootstrapAdmin" \
  -H "Content-Type: application/json" \
  -d "{\"uid\":\"TU_UID\",\"token\":\"TU_BOOTSTRAP_TOKEN\"}"

# 6) IMPORTANTÍSIMO: después de bootstrap, CAMBIA/ELIMINA BOOTSTRAP_TOKEN (para cerrar la puerta).
